# Lessons Learned: API Reference - Workflow

This document summarizes the key takeaways from the `api-reference/workflow` documentation.

- **`index.mdx`**: The `workflow` package provides essential primitives for building workflows, including context management (`getWorkflowMetadata`, `getStepMetadata`), flow control (`sleep`), external communication (`fetch`, `createHook`, `createWebhook`), streaming (`getWritable`), and custom error handling (`FatalError`, `RetryableError`). These tools are the building blocks for creating complex, resilient, and interactive workflows.

- **`create-hook.mdx`**: The `createHook()` function is a powerful tool for pausing a workflow and waiting for an external system to provide a payload. This is ideal for scenarios requiring manual approval, receiving data from a third-party service, or any situation where the workflow needs to wait for an external event before proceeding. Hooks can be strongly typed and can receive multiple payloads, making them a flexible solution for asynchronous communication.

- **`create-webhook.mdx`**: `createWebhook()` allows workflows to be suspended until an HTTP request is received, making them interactive and responsive to external events. Unlike hooks, webhooks work directly with standard `Request` and `Response` objects, enabling seamless integration with any system capable of sending HTTP requests. This is perfect for building workflows triggered by third-party services like GitHub, Slack, or Stripe, and for creating workflows that can send custom HTTP responses back to the caller.

- **`define-hook.mdx`**: `defineHook()` is a crucial utility for ensuring type safety when working with hooks. By defining the hook's payload type once, you can reuse it across your application, guaranteeing that the data sent to the hook and the data received by the workflow are always consistent. This eliminates a common source of errors and makes your workflows more robust and maintainable. Additionally, `defineHook()` supports schema validation, allowing you to validate and transform payloads before they are passed to the workflow.

- **`fatal-error.mdx`**: `FatalError` provides a way to control the retry behavior of a workflow. When a step encounters an unrecoverable error, throwing a `FatalError` will immediately stop the workflow and mark it as failed, preventing any further retries. This is essential for handling situations where retrying would be pointless or even harmful, such as when dealing with invalid input or a permanent external failure.

- **`fetch.mdx`**: The `fetch()` function in a workflow is a specialized version of the standard `fetch` API that is designed for use within a workflow. It automatically handles serialization and provides built-in retry semantics, making it easy to make HTTP requests to external services. For more advanced use cases, you can create a custom `fetch` wrapper to implement more sophisticated error handling, such as custom retry logic for rate limiting or fatal errors for client-side issues.

- **`get-step-metadata.mdx`**: `getStepMetadata()` provides access to valuable context about the current step, including the `stepId`, retry count, and timing information. This is particularly useful for implementing idempotency in external API calls, where the `stepId` can be used as an idempotency key to prevent duplicate operations. Additionally, the metadata can be used for logging, monitoring, and implementing custom error handling logic based on the number of retries.

- **`get-workflow-metadata.mdx`**: `getWorkflowMetadata()` provides access to high-level information about the current workflow execution, such as the `workflowRunId`. This is useful for logging, tracking, and auditing purposes, allowing you to correlate workflow executions with other events in your system. By logging the `workflowRunId`, you can easily trace the entire lifecycle of a workflow, from its initiation to its completion.

- **`get-writable.mdx`**: `getWritable()` is a powerful feature for streaming data out of a workflow in real-time. It provides a `WritableStream` that can be written to from both workflow and step functions, allowing you to send progress updates, logs, or any other data to an external client. This is particularly useful for long-running workflows where you want to provide immediate feedback to the user, or for streaming responses from AI models.

- **`retryable-error.mdx`**: `RetryableError` is a specialized error type that allows you to control the retry behavior of a step with more precision than a standard `Error`. By using `RetryableError`, you can specify a `retryAfter` duration, which is useful for implementing custom backoff strategies when dealing with rate-limited APIs or other transient failures. This gives you more control over how your workflow recovers from errors, making it more resilient and efficient.

- **`sleep.mdx`**: The `sleep()` function provides a way to pause a workflow for a specific duration or until a certain date without consuming any resources. This is essential for building workflows that need to wait for a period of time before continuing, such as sending a follow-up email after a week or waiting for a scheduled maintenance window to end. `sleep` is a deterministic and replay-safe operation, ensuring that your workflows will resume reliably.
